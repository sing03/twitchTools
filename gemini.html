<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Twitch 小奇點 &amp; 贈訂 資訊擷取器</title>
<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
<style>
  :root {
    --color-primary-dark: #00314F;
    --color-primary-mid: #3E6B8E;
    --color-primary-light: #FCE4A8; /* Warm yellow/orange for accents and text */
    --color-text-light: var(--color-primary-light);
    --color-background-header: var(--color-primary-dark);
    --color-shadow-dark: rgba(0, 19, 79, 0.7);
    --spacing-sm: 12px;
    --spacing-md: 24px;
    --border-radius-lg: 12px;
    --table-header-bg: var(--color-primary-dark);
    --table-row-bg: var(--color-primary-mid);
    --table-row-hover-bg: #274a71; /* Slightly darker mid for hover */
    --sidebar-bg: var(--color-primary-dark);
    --sidebar-item-bg: var(--color-primary-dark);
    --sidebar-item-hover-bg: var(--color-primary-light); /* Hover background is the light accent */
    --sidebar-item-hover-color: var(--color-primary-dark); /* Hover text is the dark primary */
  }

  /* Reset & base */
  *, *::before, *::after {
    box-sizing: border-box;
  }
  body {
    margin: 0;
    font-family: 'Inter', 'Noto Sans TC', sans-serif;
    background: var(--color-primary-dark);
    color: var(--color-text-light);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
  }
  a {
    color: inherit;
    text-decoration: none;
  }
  /* Scrollbar */
  ::-webkit-scrollbar {
    width: 12px;
    height: 12px;
  }
  ::-webkit-scrollbar-track {
    background: var(--color-primary-dark);
    border-radius: 8px;
  }
  ::-webkit-scrollbar-thumb {
    background: var(--color-primary-mid);
    border-radius: 8px;
  }
  ::-webkit-scrollbar-thumb:hover {
    background: var(--table-row-hover-bg);
  }
  /* Header */
  header {
    position: sticky;
    top: 0;
    height: 64px;
    background: var(--color-background-header);
    box-shadow: 0 2px var(--spacing-sm) var(--color-shadow-dark);
    display: flex;
    align-items: center;
    padding: 0 var(--spacing-md);
    z-index: 101;
    gap: var(--spacing-sm);
  }
  header .menu-button {
    background: transparent;
    border: none;
    color: var(--color-primary-light);
    cursor: pointer;
    font-size: 28px;
    padding: 6px 8px 6px 0;
    border-radius: var(--border-radius-lg);
    transition: background-color 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
  }
  header .menu-button:hover,
  header .menu-button:focus {
    background: rgba(252, 228, 168, 0.15); /* Light accent with transparency */
    outline: none;
  }
  header .menu-button .material-icons {
    font-size: 28px;
  }
  header .brand {
    font-weight: 900;
    font-size: clamp(1.25rem, 1.5vw, 1.75rem);
    letter-spacing: 0.08em;
    color: var(--color-primary-light);
    user-select: none;
  }

  /* Layout */
  #app {
    display: flex;
    flex: 1 1 auto;
    min-height: calc(100vh - 64px);
    overflow: hidden;
  }
  /* Sidebar */
  nav.sidebar {
    width: 280px;
    min-width: 280px;
    background: var(--sidebar-bg); /* Use CSS variable */
    display: flex;
    flex-direction: column;
    padding-top: 20px;
    color: var(--color-primary-light);
    transition: transform 0.3s ease;
    border-right: 1px solid var(--color-primary-light); /* Use CSS variable */
    z-index: 200;
  }
  nav.sidebar h2 {
    text-align: center;
    font-size: 1.4rem;
    font-weight: 700;
    margin-bottom: 32px;
    letter-spacing: 0.08em;
    user-select: none;
    color: var(--color-primary-light);
  }
  nav.sidebar ul {
    list-style: none;
    padding: 0 12px;
    margin: 0;
    flex: 1;
    overflow-y: auto;
    /* Removed background here, as it's defined on the parent nav.sidebar */
  }
  nav.sidebar ul li {
    display: flex;
    align-items: center;
    padding: 12px 16px;
    margin-bottom: 6px;
    border-radius: var(--border-radius-lg);
    cursor: pointer;
    gap: 16px;
    font-weight: 600;
    font-size: 1.05rem;
    color: var(--color-primary-light);
    user-select: none;
    transition: background-color 0.3s ease, color 0.3s ease;
    background: var(--sidebar-item-bg); /* Use CSS variable */
  }
  nav.sidebar ul li:hover,
  nav.sidebar ul li.active {
    background: var(--sidebar-item-hover-bg); /* Use CSS variable */
    color: var(--sidebar-item-hover-color); /* Use CSS variable */
  }
  /* Removed .material-icons style for sidebar li as icons are removed from HTML structure */
  nav.sidebar ul li .badge {
    background: var(--color-primary-mid); /* Adjust badge color for new theme */
    border-radius: 16px;
    padding: 2px 10px;
    font-weight: 700;
    font-size: 0.75rem;
    color: var(--color-primary-light); /* Badge text color */
    user-select: none;
    margin-left: auto; /* Push badge to the right */
    display: none; /* Controlled by JS */
  }
  /* Mobile Sidebar Hidden */
  nav.sidebar.mobile-hidden {
    transform: translateX(-100%);
    position: fixed;
    top: 64px;
    bottom: 0;
    left: 0;
    width: 280px;
    box-shadow: 4px 0 12px var(--color-shadow-dark);
  }

  /* Main Content */
  main.content {
    flex: 1;
    display: flex;
    flex-direction: column;
    padding: var(--spacing-md);
    overflow-y: auto;
  }
  #subTitle {
    font-weight: 700;
    font-size: 1.5rem;
    color: var(--color-primary-light);
    margin-bottom: var(--spacing-md);
    user-select: none;
    transition: color 0.3s ease;
  }
  main.content .input-group {
    max-width: 480px;
    margin-bottom: var(--spacing-md);
  }
  main.content label {
    display: block;
    margin-bottom: 6px;
    font-weight: 600;
    color: var(--color-primary-light);
  }
  main.content input[type="text"] {
    width: 100%;
    padding: 12px 16px;
    border-radius: var(--border-radius-lg);
    border: none;
    font-size: 1rem;
    background: var(--table-row-bg); /* Use table row bg for input */
    color: var(--color-primary-light);
    transition: background-color 0.3s ease;
  }
  main.content input[type="text"]:focus {
    background: var(--table-row-hover-bg); /* Use table row hover bg for input focus */
    outline: none;
  }
  main.content button.connect-btn,
  main.content button.export-btn {
    margin-top: 12px;
    background: var(--color-primary-dark);
    border: 2px solid var(--color-primary-light);
    color: var(--color-primary-light);
    font-weight: 700;
    cursor: pointer;
    padding: 12px 28px;
    font-size: 1rem;
    border-radius: 14px;
    box-shadow: 0 0 5px var(--color-primary-light);
    transition: background-color 0.3s ease, box-shadow 0.3s ease, color 0.3s ease; /* Added color transition */
    user-select: none;
  }
  main.content button.connect-btn:hover:enabled,
  main.content button.export-btn:hover:enabled {
    background: var(--color-primary-light);
    color: var(--color-primary-dark); /* Text changes to dark primary on hover */
    box-shadow: 0 0 15px var(--color-primary-light);
  }
  main.content button.connect-btn:disabled,
  main.content button.export-btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }
  .btn-group {
    margin-bottom: 16px;
    display: flex;
    gap: 16px;
  }
  /* Data table */
  table.event-table {
    width: 100%;
    border-collapse: separate;
    border-spacing: 0 12px;
    font-size: 0.95rem;
    color: var(--color-primary-light);
  }
  table.event-table thead th {
    text-align: left;
    font-weight: 700;
    padding: 12px 16px;
    background: var(--table-header-bg);
    user-select: none;
    /* Added border-radius to match row style */
    border-top-left-radius: var(--border-radius-lg);
    border-top-right-radius: var(--border-radius-lg);
  }
  table.event-table tbody tr {
    background: var(--table-row-bg);
    border-radius: var(--border-radius-lg); /* Overall rounded corners for the row */
    transition: background-color 0.3s ease;
  }
  table.event-table tbody tr:hover {
    background: var(--table-row-hover-bg);
  }
  table.event-table tbody td {
    padding: 12px 16px;
    vertical-align: middle;
    /* Removed specific border-radius from here to ensure only first/last cells have them */
    /* This rule should NOT apply any border-radius */
  }
  /* Adjustments for rounded corners on first/last cells */
  table.event-table tbody tr td:first-child {
    border-top-left-radius: var(--border-radius-lg);
    border-bottom-left-radius: var(--border-radius-lg);
  }
  table.event-table tbody tr td:last-child {
    border-top-right-radius: var(--border-radius-lg);
    border-bottom-right-radius: var(--border-radius-lg);
  }

  table.event-table tbody td > .user-name {
    font-weight: 600;
    max-width: 380px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  table.event-table tbody td .material-icons {
    vertical-align: middle;
    font-size: 20px;
    margin-right: 4px;
    color: var(--color-primary-light);
  }
  /* Scroll container for table */
  .table-wrapper {
    overflow-x: auto;
    padding-bottom: 12px;
  }

  /* Toast Notifications */
  #toast-container {
    position: fixed;
    bottom: 40px;
    right: 40px;
    max-width: 320px;
    z-index: 9999;
  }
  .toast {
    background: var(--color-primary-dark);
    padding: 14px 20px;
    border-radius: var(--border-radius-lg);
    margin-top: 10px;
    color: var(--color-primary-light);
    box-shadow: 0 4px 20px rgba(62, 107, 142, 0.7); /* Use primary-mid for shadow */
    display: flex;
    align-items: center;
    gap: 16px;
    opacity: 0;
    transform: translateX(100%);
    animation: slideInToast 0.3s forwards;
    font-weight: 600;
  }
  .toast-icon {
    font-size: 24px;
    color: var(--color-primary-light);
    flex-shrink: 0;
  }
  @keyframes slideInToast {
    to {
      opacity: 1;
      transform: translateX(0);
    }
  }
  /* Footer */
  footer {
    background: var(--color-primary-dark);
    color: var(--color-primary-light);
    font-size: 0.85rem;
    text-align: center;
    padding: 12px 16px;
    user-select: none;
  }
  /* Responsive */
  @media (max-width: 1023px) {
    nav.sidebar {
      position: fixed;
      top: 64px;
      left: 0;
      bottom: 0;
      transform: translateX(-100%);
      width: 280px;
      z-index: 20;
      box-shadow: 4px 0 12px var(--color-shadow-dark);
    }
    nav.sidebar.mobile-visible {
      transform: translateX(0);
      transition: transform 0.3s ease;
    }
    #app {
      padding-left: 0;
    }
  }
  @media (max-width: 639px) {
    header {
      padding: 0 16px;
    }
    main.content {
      padding: 16px 20px;
    }
    table.event-table {
      font-size: 0.8rem;
    }
    table.event-table thead th,
    table.event-table tbody td {
      padding: 8px 10px;
    }
    nav.sidebar ul li {
      padding: 9px 12px;
      font-size: 0.9rem;
    }
  }
</style>
</head>
<body>
<header role="banner" aria-label="主選單區">
  <button id="menu-toggle" class="menu-button" aria-label="切換選單" title="切換選單" aria-expanded="false" aria-controls="sidebar">
    <span class="material-icons">menu</span>
  </button>
  <div class="brand" tabindex="0" id="mainTitle">Twitch Bits 與 贈訂擷取</div>
</header>
<div id="app">
  <nav class="sidebar" id="sidebar" aria-label="主要導航">
    <h2 tabindex="0">事件分類</h2>
    <ul>
      <li class="active" data-type="all" tabindex="0" role="button" aria-pressed="true" aria-label="顯示全部事件">
        <span class="material-icons">view_stream</span>全部事件<span class="badge" id="badge-all"></span>
      </li>
      <li data-type="bits" tabindex="0" role="button" aria-pressed="false" aria-label="顯示小奇點">
        <span class="material-icons">local_play</span>小奇點 (Bits)<span class="badge" id="badge-bits"></span>
      </li>
      <li data-type="gift" tabindex="0" role="button" aria-pressed="false" aria-label="顯示贈送訂閱">
        <span class="material-icons">card_giftcard</span>贈送訂閱<span class="badge" id="badge-gift"></span>
      </li>
    </ul>
  </nav>
  <main class="content" role="main">
    <p id="subTitle" aria-live="polite" aria-atomic="true" style="margin-top:0; margin-bottom:24px;">全部事件</p>
    <section aria-label="頻道設定區" class="input-group">
      <label for="channelName">輸入要觀察的 Twitch 頻道ID：</label>
      <input type="text" id="channelName" placeholder="例如：ninja" aria-describedby="channelHelp" autocomplete="off" />
      <button class="connect-btn" id="connectBtn" disabled>連線 Twitch IRC</button>
      <small id="channelHelp">輸入正確的頻道ID以擷取聊天室事件。</small>
    </section>
    <section aria-label="匯出功能" class="btn-group" style="user-select:none;">
      <button class="export-btn" id="exportCsvBtn" aria-label="下載 CSV 檔案">下載 CSV 檔案</button>
      <button class="export-btn" id="clearDataBtn" aria-label="清除所有數據">清除所有數據</button>
    </section>
    <section aria-label="事件列表" class="table-wrapper" tabindex="0">
      <table class="event-table" role="grid" aria-live="polite" aria-relevant="all">
        <thead>
          <tr>
            <th scope="col" style="width: 160px;">時間</th>
            <th scope="col" style="width: 380px;">名稱</th>
            <th scope="col" style="width: 300px;">類型</th>
            <th scope="col" style="width: 160px;">數量</th>
          </tr>
        </thead>
        <tbody id="eventTableBody">
          <!-- 動態項目 -->
        </tbody>
      </table>
    </section>
  </main>
</div>
<div id="toast-container" aria-live="assertive" aria-atomic="true"></div>
<footer role="contentinfo">
  © 2024 Twitch 小奇點與 贈訂擷取器 | 開發者: BLACKBOXAI 版權所有
</footer>
<script>
(() => {
  'use strict';

  // Define the key name for sessionStorage
  const SESSION_STORAGE_KEY = 'twitch_events_data';

  /**
   * Formats a Date object into a localized date and time string.
   * @param {Date} date - The Date object to format.
   * @returns {string} The formatted date and time string.
   */
  function formatDateTime(date) {
    return date.toLocaleString(undefined, {
      hour12: false,
      year: 'numeric', month: '2-digit', day: '2-digit',
      hour: '2-digit', minute: '2-digit', second: '2-digit'
    });
  }

  /**
   * Manages and displays Toast notifications.
   */
  class ToastManager {
    constructor(container) {
      if (!container) {
        console.error("ToastManager: Container element not found.");
        return;
      }
      this.container = container;
      this.toasts = [];
    }

    /**
     * Displays a Toast notification.
     * @param {string} message - The notification message.
     * @param {string} [icon='info'] - The Material Icons icon name.
     * @param {number} [duration=4000] - The duration in milliseconds for which the toast is displayed.
     */
    show(message, icon = 'info', duration = 4000) {
      if (!this.container) return; // Safely exit if container is null

      const toast = document.createElement('div');
      toast.className = 'toast';
      toast.setAttribute('role', 'alert');
      toast.setAttribute('aria-live', 'assertive');
      toast.setAttribute('aria-atomic', 'true');
      toast.innerHTML = `<span class="material-icons toast-icon">${icon}</span><span>${message}</span>`;
      this.container.appendChild(toast);
      this.toasts.push(toast);

      // Fade out and remove after duration
      setTimeout(() => {
        toast.style.opacity = '0';
        toast.style.transform = 'translateX(100%)';
        setTimeout(() => {
          if (this.container.contains(toast)) {
            this.container.removeChild(toast);
          }
          this.toasts = this.toasts.filter(t => t !== toast);
        }, 300); // Match CSS transition duration
      }, duration);
    }
  }

  /**
   * Saves event data to sessionStorage.
   */
  function saveEventsToSessionStorage() {
    try {
      // Convert Date objects to ISO strings before stringifying to handle them correctly
      const serializableEvents = state.events.map(event => ({
        ...event,
        timestamp: event.timestamp.toISOString() // Convert Date object to string
      }));
      sessionStorage.setItem(SESSION_STORAGE_KEY, JSON.stringify(serializableEvents));
    } catch (e) {
      // Handle QuotaExceededError when sessionStorage is full
      if (e.name === 'QuotaExceededError') {
        toastMgr.show('瀏覽器儲存空間已滿，新數據將無法保存。', 'warning', 8000);
        console.warn('Session storage quota exceeded. New data might not be saved.');
      } else {
        console.error("無法將數據儲存到 sessionStorage:", e);
      }
    }
  }

  /**
   * Loads event data from sessionStorage.
   * @returns {Array} The loaded array of event data.
   */
  function loadEventsFromSessionStorage() {
    try {
      const storedData = sessionStorage.getItem(SESSION_STORAGE_KEY);
      if (storedData) {
        // Convert ISO strings back to Date objects after parsing
        const parsedData = JSON.parse(storedData);
        return parsedData.map(event => ({
          ...event,
          timestamp: new Date(event.timestamp) // Convert string back to Date object
        }));
      }
    } catch (e) {
      console.error("無法從 sessionStorage 載入數據:", e);
      // If loading fails (e.g., corrupted data), return an empty array
    }
    return [];
  }

  // Application state management
  const state = {
    socket: null,
    connected: false,
    events: loadEventsFromSessionStorage(), // Load data from sessionStorage on initialization
    filterType: 'all', // Current filter type ('all', 'bits', 'gift')
    channel: '', // Current connected channel name
  };

  // Cache UI elements
  const ui = {
    channelInput: document.getElementById('channelName'),
    connectBtn: document.getElementById('connectBtn'),
    eventTableBody: document.getElementById('eventTableBody'),
    sidebar: document.getElementById('sidebar'),
    menuToggle: document.getElementById('menu-toggle'),
    badges: {
      all: document.getElementById('badge-all'),
      bits: document.getElementById('badge-bits'),
      gift: document.getElementById('badge-gift')
    },
    exportCsvBtn: document.getElementById('exportCsvBtn'),
    clearDataBtn: document.getElementById('clearDataBtn'), // Added UI element for clear data button
    subTitle: document.getElementById('subTitle'),
    sidebarItems: document.querySelectorAll('nav.sidebar ul li')
  };

  // Initialize Toast manager
  const toastMgr = new ToastManager(document.getElementById('toast-container'));

  /**
   * Validates the Twitch channel name format.
   * @param {string} name - The channel name.
   * @returns {boolean} True if the name is valid.
   */
  function validateChannelName(name) {
    if (typeof name !== 'string') return false;
    // Twitch channel names are typically 4-25 lowercase letters, numbers, or underscores.
    return /^[a-z0-9_]{4,25}$/.test(name.trim().toLowerCase());
  }

  // Channel input field listener: enable/disable connect button
  ui.channelInput.addEventListener('input', () => {
    ui.connectBtn.disabled = !validateChannelName(ui.channelInput.value);
  });

  /**
   * Twitch IRC client class.
   */
  class TwitchIRC {
    constructor(channel, token = '') {
      this.channel = channel.toLowerCase();
      this.token = token;
      this.websocket = null;
      this.listeners = {};
      this.reconnectInterval = 5000; // 5-second reconnect interval
      this.connected = false;
      this.nick = 'justinfan' + Math.floor(Math.random() * 80000); // Anonymous username
      this._reconnectTimer = null;
    }

    /**
     * Establishes a WebSocket connection.
     */
    connect() {
      if (this.connected) return;
      // Clear any existing reconnect timer
      if (this._reconnectTimer) {
        clearTimeout(this._reconnectTimer);
        this._reconnectTimer = null;
      }

      const wsUrl = 'wss://irc-ws.chat.twitch.tv:443';
      this.websocket = new WebSocket(wsUrl);
      this.websocket.addEventListener('open', () => this.onOpen());
      this.websocket.addEventListener('message', e => this.onMessage(e));
      this.websocket.addEventListener('close', e => this.onClose(e));
      this.websocket.addEventListener('error', e => this.onError(e));
    }

    /**
     * Disconnects the WebSocket connection.
     */
    disconnect() {
      if (!this.connected) return;
      this.websocket.close(1000, 'Client disconnect');
      this.connected = false;
      if (this._reconnectTimer) {
        clearTimeout(this._reconnectTimer);
        this._reconnectTimer = null;
      }
    }

    /**
     * Handler for WebSocket open event.
     */
    onOpen() {
      this.connected = true;
      const nick = this.nick;
      this.sendRaw(`PASS ${this.token || 'SCHMOOPIIE'}`);
      this.sendRaw(`NICK ${nick}`);
      // Request Twitch-specific capabilities to get tags, commands, and membership info
      this.sendRaw('CAP REQ :twitch.tv/tags twitch.tv/commands twitch.tv/membership');
      this.sendRaw(`JOIN #${this.channel}`);
      this.emit('open');
    }

    /**
     * Handler for WebSocket message event.
     * @param {MessageEvent} event - The WebSocket message event.
     */
    onMessage(event) {
      const msg = event.data;
      console.log('Received raw IRC message:', msg); // Added for debugging
      if (msg.startsWith('PING')) {
        this.sendRaw('PONG :tmi.twitch.tv'); // Respond to PING to keep connection alive
        return;
      }
      // Twitch IRC messages can contain multiple messages, need to split and process
      msg.split('\r\n').forEach(line => {
        if (line) {
          const parsed = this.parseIRCMessage(line);
          if (parsed) {
            this.emit('message', parsed);
          }
        }
      });
    }

    /**
     * Handler for WebSocket close event.
     * @param {CloseEvent} event - The WebSocket close event.
     */
    onClose(event) {
      this.connected = false;
      this.emit('close', event);
      // If not a clean close, attempt to reconnect
      if (!event.wasClean) {
        console.warn(`WebSocket closed uncleanly. Attempting reconnect in ${this.reconnectInterval / 1000}s.`, event);
        if (!this._reconnectTimer) {
          this._reconnectTimer = setTimeout(() => {
            this._reconnectTimer = null;
            this.connect(); // Attempt to reconnect
          }, this.reconnectInterval);
        }
      } else {
        console.log('WebSocket closed cleanly.', event);
      }
    }

    /**
     * Handler for WebSocket error event.
     * @param {Event} event - The WebSocket error event.
     */
    onError(event) {
      console.error('WebSocket Error:', event);
      this.emit('error', event);
      // Error event typically followed by a close event, handled in onClose
    }

    /**
     * Sends a raw IRC command to the WebSocket.
     * @param {string} cmd - The IRC command to send.
     */
    sendRaw(cmd) {
      if (this.connected && this.websocket && this.websocket.readyState === WebSocket.OPEN) {
        this.websocket.send(cmd + '\r\n');
      } else {
        console.warn('WebSocket not open. Cannot send command:', cmd);
      }
    }

    /**
     * Parses a raw IRC message string.
     * This is a simplified version of IRC protocol parsing, used to extract tags, commands, and parameters from Twitch messages.
     * @param {string} raw - The raw IRC message string.
     * @returns {Object|null} The parsed message object or null.
     */
    parseIRCMessage(raw) {
      const message = {
        raw,
        tags: {},
        prefix: '',
        command: '',
        params: [],
        trailing: '', // The last part of the message, usually chat content
      };

      let rest = raw;

      // Parse Tags
      if (rest.startsWith('@')) {
        const endTags = rest.indexOf(' ');
        if (endTags === -1) return null; // Invalid format
        const tagsStr = rest.slice(1, endTags);
        rest = rest.slice(endTags + 1);
        tagsStr.split(';').forEach(tagPair => {
          const [key, ...vals] = tagPair.split('=');
          message.tags[key] = vals.join('=') || ''; // Handle cases where value might contain '='
        });
      }

      // Parse Prefix
      if (rest.startsWith(':')) {
        const endPrefix = rest.indexOf(' ');
        if (endPrefix === -1) return null; // Invalid format
        message.prefix = rest.slice(1, endPrefix);
        rest = rest.slice(endPrefix + 1);
      }

      // Parse Command and Parameters
      const parts = rest.split(' :'); // Split trailing message from other parts
      const commandAndParams = parts[0].trim().split(' ');

      message.command = commandAndParams[0];
      message.params = commandAndParams.slice(1);
      message.trailing = parts.length > 1 ? parts.slice(1).join(' :') : '';

      return message;
    }

    /**
     * Registers an event listener.
     * @param {string} event - The event name.
     * @param {Function} cb - The callback function.
     */
    on(event, cb) {
      if (!this.listeners[event]) {
        this.listeners[event] = [];
      }
      this.listeners[event].push(cb);
    }

    /**
     * Removes an event listener.
     * @param {string} event - The event name.
     * @param {Function} cb - The callback function to remove.
     */
    off(event, cb) {
      if (!this.listeners[event]) return;
      this.listeners[event] = this.listeners[event].filter(fn => fn !== cb);
    }

    /**
     * Emits an event.
     * @param {string} event - The event name.
     * @param {*} data - The data to pass to the callback functions.
     */
    emit(event, data) {
      if (this.listeners[event]) {
        this.listeners[event].forEach(cb => cb(data));
      }
    }
  }

  /**
   * Returns Material Icon name and display text based on Event Type.
   * @param {string} type - The event type ('all', 'bits', 'gift').
   * @returns {{icon: string, text: string}} An object containing the icon name and display text.
   */
  function getEventIconAndText(type) {
    switch (type) {
      case 'all': return { icon: 'view_stream', text: '全部事件' };
      case 'bits': return { icon: 'local_play', text: '小奇點 (Bits)' };
      case 'gift': return { icon: 'card_giftcard', text: '贈送訂閱' };
      default: return { icon: 'info', text: type };
    }
  }

  /**
   * Parses raw IRC message from Twitch, extracting structured data for Bits or Gifted Subs events.
   * @param {Object} msg - The IRC message object parsed by `parseIRCMessage`.
   * @returns {Object|null} The structured event object or null.
   */
  function parseTwitchEvent(msg) {
    const tags = msg.tags;
    const command = msg.command;
    const trailing = msg.trailing;
    const timestamp = new Date(); // Use current time as event time

    const username = tags['login'] || ''; // login-name (lowercase)
    const displayName = tags['display-name'] || username; // user-name (display name, preserve case)

    // Format name as display-name (login-name)
    // If login-name and display-name are the same, display only display-name
    // If only login-name exists, display login-name
    // If neither exists, display '匿名' (anonymous)
    let combinedNameFormatted;
    if (displayName && username && displayName.toLowerCase() !== username.toLowerCase()) { // Compare case-insensitively
      combinedNameFormatted = `${displayName} (${username})`;
    } else if (displayName) {
      combinedNameFormatted = displayName;
    } else if (username) {
      combinedNameFormatted = username;
    } else {
      combinedNameFormatted = '匿名';
    }

    let event = null;

    // Handle Bits event (PRIVMSG with bits tag)
    if (command === 'PRIVMSG' && tags.bits && tags.bits !== '0') {
      const bitsAmount = parseInt(tags.bits, 10);
      event = {
        timestamp,
        username,
        displayName,
        combinedName: combinedNameFormatted, // Use the new formatted name
        type: 'bits',
        amount: bitsAmount,
        message: trailing || '', // Chat message accompanying the bits
        rawTags: tags,
      };
    }
    // Handle Gifted Subscription event (NOTICE with subgift or submysterygift tag)
    else if (command === 'NOTICE' && (tags['msg-id'] === 'subgift' || tags['msg-id'] === 'submysterygift')) {
      const tier = tags['msg-param-sub-plan'] || '';
      const tierMap = {'1000':'Tier 1','2000':'Tier 2','3000':'Tier 3'};
      const tierName = tierMap[tier] || tier;
      let amount = 1;

      if (tags['msg-id'] === 'submysterygift') {
        amount = parseInt(tags['msg-param-mass-gift-count'] || '1', 10);
      }

      event = {
        timestamp,
        username, // Gifter's login name
        displayName, // Gifter's display name
        combinedName: combinedNameFormatted, // Use the new formatted name
        type: 'gift',
        amount: amount,
        recipientName: tags['msg-param-recipient-display-name'] || '', // Recipient of single gift
        tier: tierName,
        message: trailing || '', // Usually empty string or simple notification message
        rawTags: tags,
      };
    } else if (command === 'NOTICE') {
      // Log other NOTICE messages to help debug if gift notices are different
      console.log('Received NOTICE command but not a recognized gift event:', msg.raw); // Log the raw message
      console.log('NOTICE tags:', tags);
    }
    return event;
  }

  /**
   * Processes and renders a newly received event.
   * @param {Object} event - The parsed event object.
   */
  function renderEvent(event) {
    if (!event) return;

    // Add new event to the beginning of the list
    state.events.unshift(event);

    // Removed the 200-item limit, allowing data to accumulate until sessionStorage is full
    // if (state.events.length > 200) {
    //   state.events.pop(); // Remove the oldest event
    // }

    saveEventsToSessionStorage(); // Save to sessionStorage

    updateBadges();
    renderTable(state.filterType);

    // Display Toast only if page is visible
    if (!document.hidden) {
      const toastIconText = getEventIconAndText(event.type);
      toastMgr.show(renderToastMessage(event), toastIconText.icon);
    }
  }

  /**
   * Updates badge counts in the sidebar.
   */
  function updateBadges() {
    const allCount = state.events.length;
    const bitsCount = state.events.filter(e => e.type === 'bits').length;
    const giftCount = state.events.filter(e => e.type === 'gift').length;

    // Update and display badges
    if (ui.badges.all) {
      ui.badges.all.textContent = allCount;
      ui.badges.all.style.display = allCount > 0 ? 'inline-block' : 'none';
    }
    if (ui.badges.bits) {
      ui.badges.bits.textContent = bitsCount;
      ui.badges.bits.style.display = bitsCount > 0 ? 'inline-block' : 'none';
    }
    if (ui.badges.gift) {
      ui.badges.gift.textContent = giftCount;
      ui.badges.gift.style.display = giftCount > 0 ? 'inline-block' : 'none';
    }
  }

  /**
   * Renders the event table based on the current filter type.
   * @param {string} [filter='all'] - The filter type ('all', 'bits', 'gift').
   */
  function renderTable(filter = 'all') {
    ui.eventTableBody.innerHTML = ''; // Clear table content

    const filteredEvents = state.events.filter(e => filter === 'all' || e.type === filter);

    if (filteredEvents.length === 0) {
      const noDataRow = document.createElement('tr');
      const noDataCell = document.createElement('td');
      noDataCell.colSpan = 4;
      noDataCell.style.textAlign = 'center';
      noDataCell.textContent = '目前沒有事件數據。';
      noDataRow.appendChild(noDataCell);
      ui.eventTableBody.appendChild(noDataRow);
      return;
    }

    // Optimize DOM insertion using DocumentFragment
    const fragment = document.createDocumentFragment();

    for (const ev of filteredEvents) {
      const tr = document.createElement('tr');

      const timeTd = document.createElement('td');
      timeTd.textContent = formatDateTime(ev.timestamp);
      timeTd.title = ev.timestamp.toISOString(); // Show full ISO time on hover

      const nameTd = document.createElement('td');
      // Use the combinedName field processed by parseTwitchEvent
      nameTd.textContent = ev.combinedName;
      nameTd.className = 'user-name';
      // More detailed tooltip with original display name and login name
      nameTd.title = `顯示名稱: ${ev.displayName || '匿名'} / 登入名稱: ${ev.username || '匿名'}`;

      const typeTd = document.createElement('td');
      const typeInfo = getEventIconAndText(ev.type);
      typeTd.innerHTML = `<span class="material-icons" aria-hidden="true">${typeInfo.icon}</span>${typeInfo.text}`;

      const amtTd = document.createElement('td');
      amtTd.textContent = ev.amount.toString();
      if (ev.type === 'gift') {
        amtTd.textContent = `${ev.amount} (${ev.tier})`;
      }

      tr.append(timeTd, nameTd, typeTd, amtTd);
      fragment.appendChild(tr);
    }
    ui.eventTableBody.appendChild(fragment);
  }

  /**
   * Generates Toast message content based on event type.
   * @param {Object} ev - The event object.
   * @returns {string} The message string suitable for display in a Toast.
   */
  function renderToastMessage(ev) {
    if (!ev) return '';
    if (ev.type === 'bits') {
      return `觀眾 ${ev.combinedName} 贊助了 ${ev.amount} 小奇點！`;
    } else if (ev.type === 'gift') {
      if (ev.amount > 1) {
        return `觀眾 ${ev.combinedName} 贈送了 ${ev.amount} 個訂閱 (${ev.tier})！`;
      } else {
        // For single gifted subs, RecipientName might be missing in EventSub V1, but IRC might provide it.
        // Ensure to display anonymous or unknown if recipientName is not available.
        return `觀眾 ${ev.combinedName} 贈送了一個訂閱 (${ev.tier})${ev.recipientName ? ` 給 ${ev.recipientName}` : ''}！`;
      }
    }
    return '';
  }

  // Connect/Disconnect button click handler
  ui.connectBtn.addEventListener('click', () => {
    if (state.connected) {
      disconnectIRC();
    } else {
      const channel = ui.channelInput.value.trim().toLowerCase();
      if (!validateChannelName(channel)) {
        toastMgr.show('頻道名稱格式錯誤，請輸入有效的頻道名稱。', 'error', 6000);
        return;
      }
      connectIRC(channel);
    }
  });

  /**
   * Connects to the Twitch IRC chat.
   * @param {string} channel - The Twitch channel name to connect to.
   */
  function connectIRC(channel) {
    if (state.connected) return;

    state.channel = channel;
    state.socket = new TwitchIRC(channel);

    state.socket.on('open', () => {
      state.connected = true;
      ui.connectBtn.textContent = '中斷連線';
      ui.connectBtn.disabled = false; // Enable disconnect button after successful connection
      toastMgr.show(`已連線至 Twitch 頻道：${channel}`, 'check_circle', 3000);
      // Removed clearEvents() here to preserve session storage data
    });

    state.socket.on('message', msg => {
      const event = parseTwitchEvent(msg);
      if (event) {
        renderEvent(event);
      }
    });

    state.socket.on('close', (event) => { // Receive event parameter
      state.connected = false;
      ui.connectBtn.textContent = '連線 Twitch IRC';
      ui.connectBtn.disabled = false; // Re-enable connect button after disconnection
      // Provide more specific message based on clean close event
      if (event && event.wasClean) {
        toastMgr.show('連線已斷開', 'info', 3000);
      } else {
        toastMgr.show('連線意外斷開，正在嘗試重連...', 'warning', 5000);
      }
    });

    state.socket.on('error', e => {
      // Errors are typically followed by a close event, which handles reconnect.
      // This is for logging and a separate error toast to avoid duplicate reconnect messages.
      toastMgr.show('連線錯誤，請檢查頻道名稱或網路連線。', 'error', 6000);
      console.error('WebSocket 錯誤:', e);
    });

    ui.connectBtn.disabled = true; // Disable button while connecting
    state.socket.connect();
  }

  /**
   * Disconnects from Twitch IRC.
   */
  function disconnectIRC() {
    if (state.socket) {
      state.socket.disconnect(); // Triggers onClose event, which handles cleanup
      toastMgr.show('已手動斷開連線', 'info', 3000);
    }
  }

  /**
   * Clears all stored events and re-renders the table and badges.
   */
  function clearEvents() {
    state.events = [];
    sessionStorage.removeItem(SESSION_STORAGE_KEY); // Completely remove data from sessionStorage
    toastMgr.show('所有數據已清除。', 'info', 3000);
    updateBadges();
    renderTable(state.filterType);
  }

  // Sidebar item click handler
  ui.sidebarItems.forEach(li => {
    li.addEventListener('click', () => {
      const type = li.dataset.type;
      changeFilter(type);
      setActiveSidebarItem(li);

      // Update subtitle text (excluding icons and badge text)
      if (ui.subTitle) {
        const typeInfo = getEventIconAndText(type);
        ui.subTitle.textContent = typeInfo.text;
      }
    });

    // Keyboard navigation (Enter/Space) for sidebar items
    li.addEventListener('keydown', e => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault(); // Prevent page scrolling
        li.click();
      }
    });
  });

  /**
   * Changes the event filter type and re-renders the table.
   * @param {string} type - The new filter type ('all', 'bits', 'gift').
   */
  function changeFilter(type) {
    state.filterType = type;
    renderTable(type);
  }

  /**
   * Sets the active style for the current sidebar item.
   * @param {HTMLElement} activeLi - The currently clicked or selected sidebar `<li>` element.
   */
  function setActiveSidebarItem(activeLi) {
    ui.sidebarItems.forEach(li => {
      li.classList.remove('active');
      li.setAttribute('aria-pressed', 'false');
    });
    if (activeLi) {
      activeLi.classList.add('active');
      activeLi.setAttribute('aria-pressed', 'true');
    }
  }

  // Menu toggle button (for mobile sidebar)
  ui.menuToggle.addEventListener('click', () => {
    const isOpen = ui.sidebar.classList.contains('mobile-visible');
    if (isOpen) {
      ui.sidebar.classList.remove('mobile-visible');
      ui.menuToggle.setAttribute('aria-expanded', 'false');
    } else {
      ui.sidebar.classList.add('mobile-visible');
      ui.menuToggle.setAttribute('aria-expanded', 'true');
    }
  });

  // Application startup initialization
  updateBadges(); // Update badges on first load
  renderTable(state.filterType); // Render table on first load (including loaded data)

  // Global keyboard event listener: Spacebar to toggle connection (unless in input field)
  window.addEventListener('keydown', e => {
    if (e.key === ' ' && document.activeElement !== ui.channelInput) {
      e.preventDefault(); // Prevent page scrolling
      ui.connectBtn.click();
    }
  });

  // Accessibility: Handle first Tab key press to add visible focus for keyboard navigation
  function handleFirstTab(e) {
    if (e.key === 'Tab') {
      document.body.classList.add('user-is-tabbing');
      window.removeEventListener('keydown', handleFirstTab);
    }
  }
  window.addEventListener('keydown', handleFirstTab);

  // Export CSV button click handler
  ui.exportCsvBtn.addEventListener('click', () => {
    if (state.events.length === 0) {
      toastMgr.show('沒有可匯出的事件資料。', 'warning', 3000);
      return;
    }

    const headers = ['時間', '名稱', '類型', '數量'];
    const rows = state.events.map(ev => [
      formatDateTime(ev.timestamp),
      ev.combinedName, // Use the new formatted name
      getEventIconAndText(ev.type).text, // Use helper function to get type text
      ev.type === 'gift' ? `${ev.amount} (${ev.tier})` : ev.amount.toString() // Display tier for gifted subs
    ]);

    // Generate CSV content
    const csvContent =
      headers.map(h => `"${String(h).replace(/"/g, '""')}"`).join(',') + '\n' + // Ensure headers are also correctly CSV formatted
      rows.map(r =>
        r.map(field =>
          `"${String(field).replace(/"/g, '""')}"` // Enclose each field in double quotes and escape internal double quotes
        ).join(',')
      ).join('\n');

    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    const timestamp = new Date().toISOString().replace(/[-:.]/g, '').slice(0,15);
    link.download = `twitch_bits_gifts_${timestamp}.csv`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url); // Release URL object resources

    toastMgr.show('CSV 檔案已準備好下載。', 'check_circle', 3000);
  });

  // Clear Data button click handler
  ui.clearDataBtn.addEventListener('click', () => {
    clearEvents(); // Call the clearEvents function
  });
})();
</script>
</body>
</html>
